# bin-talk-manager Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build bin-talk-manager microservice with clean architecture, threading, and reactions

**Architecture:** Three-table model (talks, messages, participants), RabbitMQ RPC communication, commondatabasehandler pattern for database operations

**Tech Stack:** Go, MySQL, Redis, RabbitMQ, Squirrel query builder, gomock for testing

---

## Phase 1: Service Scaffolding

### Task 1.1: Create Directory Structure

**Files:**
- Create: `bin-talk-manager/` (new service directory)
- Create: `bin-talk-manager/cmd/talk-manager/`
- Create: `bin-talk-manager/models/`
- Create: `bin-talk-manager/pkg/`
- Create: `bin-talk-manager/internal/config/`
- Create: `bin-talk-manager/k8s/`
- Create: `bin-talk-manager/scripts/database_scripts/`

**Step 1: Create base directories**

Run:
```bash
cd /home/pchero/gitvoipbin/monorepo
mkdir -p bin-talk-manager/{cmd/talk-manager,models,pkg,internal/config,k8s,scripts/database_scripts}
```

**Step 2: Verify structure**

Run: `tree -L 2 -d bin-talk-manager`
Expected:
```
bin-talk-manager
├── cmd
│   └── talk-manager
├── internal
│   └── config
├── k8s
├── models
├── pkg
└── scripts
    └── database_scripts
```

**Step 3: Commit**

```bash
git add bin-talk-manager/
git commit -m "feat(talk-manager): create service directory structure"
```

---

### Task 1.2: Initialize Go Module

**Files:**
- Create: `bin-talk-manager/go.mod`
- Create: `bin-talk-manager/go.sum`
- Create: `bin-talk-manager/.gitignore`

**Step 1: Create go.mod with replace directives**

Content for `bin-talk-manager/go.mod`:
```go
module monorepo/bin-talk-manager

go 1.22

require (
	github.com/go-redis/redis/v8 v8.11.5
	github.com/go-sql-driver/mysql v1.7.1
	github.com/gofrs/uuid v4.4.0+incompatible
	github.com/Masterminds/squirrel v1.5.4
	github.com/rabbitmq/amqp091-go v1.9.0
	github.com/sirupsen/logrus v1.9.3
	github.com/spf13/cobra v1.8.0
	github.com/spf13/viper v1.18.2
	github.com/prometheus/client_golang v1.18.0
	go.uber.org/mock v0.4.0
	monorepo/bin-common-handler v0.0.0
)

replace monorepo/bin-common-handler => ../bin-common-handler
```

**Step 2: Create .gitignore**

Content for `bin-talk-manager/.gitignore`:
```
/vendor/
/bin/
*.test
*.out
```

**Step 3: Download dependencies**

Run:
```bash
cd bin-talk-manager
go mod download
go mod tidy
```

Expected: Dependencies downloaded successfully

**Step 4: Commit**

```bash
git add go.mod go.sum .gitignore
git commit -m "feat(talk-manager): initialize Go module with dependencies"
```

---

### Task 1.3: Add Database Migration Scripts

**Files:**
- Create: `bin-dbscheme-manager/bin-manager/main/versions/<hash>_talk_create_tables.py`

**Step 1: Create Alembic migration file**

Run:
```bash
cd bin-dbscheme-manager/bin-manager
alembic -c alembic.ini revision -m "talk create tables talk_chats talk_messages talk_participants"
```

Expected: Creates file like `abc123_talk_create_tables_talk_chats_talk_messages_talk_participants.py`

**Step 2: Edit migration file with SQL**

Find the created file and add this content:
```python
"""talk create tables talk_chats talk_messages talk_participants

Revision ID: <auto-generated>
Revises: <previous-revision>
Create Date: 2026-01-17

"""
from alembic import op

revision = '<auto-generated>'
down_revision = '<previous-revision>'
branch_labels = None
depends_on = None


def upgrade():
    # Create talk_chats table
    op.execute("""
        CREATE TABLE talk_chats (
            id              BINARY(16) PRIMARY KEY,
            customer_id     BINARY(16) NOT NULL,
            type            VARCHAR(255) NOT NULL,
            tm_create       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
            tm_update       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
            tm_delete       DATETIME(6) NULL,
            INDEX idx_customer_id (customer_id)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
    """)

    # Create talk_participants table
    op.execute("""
        CREATE TABLE talk_participants (
            id              BINARY(16) PRIMARY KEY,
            chat_id         BINARY(16) NOT NULL,
            owner_type      VARCHAR(255) NOT NULL,
            owner_id        BINARY(16) NOT NULL,
            tm_joined       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
            INDEX idx_chat_id (chat_id),
            INDEX idx_owner (owner_type, owner_id),
            UNIQUE KEY unique_participant (chat_id, owner_type, owner_id),
            FOREIGN KEY (chat_id) REFERENCES talk_chats(id) ON DELETE CASCADE
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
    """)

    # Create talk_messages table
    op.execute("""
        CREATE TABLE talk_messages (
            id              BINARY(16) PRIMARY KEY,
            customer_id     BINARY(16) NOT NULL,
            chat_id         BINARY(16) NOT NULL,
            parent_id       BINARY(16) NULL,
            owner_type      VARCHAR(255) NOT NULL,
            owner_id        BINARY(16) NOT NULL,
            type            VARCHAR(255) NOT NULL,
            text            TEXT,
            medias          JSON,
            metadata        JSON,
            tm_create       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
            tm_update       DATETIME(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
            tm_delete       DATETIME(6) NULL,
            INDEX idx_chat_id (chat_id),
            INDEX idx_parent_id (parent_id),
            INDEX idx_customer_id (customer_id),
            INDEX idx_owner (owner_type, owner_id),
            FOREIGN KEY (chat_id) REFERENCES talk_chats(id) ON DELETE CASCADE,
            FOREIGN KEY (parent_id) REFERENCES talk_messages(id) ON DELETE SET NULL
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
    """)


def downgrade():
    op.execute("DROP TABLE IF EXISTS talk_messages")
    op.execute("DROP TABLE IF EXISTS talk_participants")
    op.execute("DROP TABLE IF EXISTS talk_chats")
```

**Step 3: Commit migration**

```bash
cd /home/pchero/gitvoipbin/monorepo
git add bin-dbscheme-manager/bin-manager/main/versions/*.py
git commit -m "feat(dbscheme): add talk-manager database tables"
```

---

### Task 1.4: Create SQLite Test SQL Files

**Files:**
- Create: `bin-talk-manager/scripts/database_scripts/table_talks.sql`
- Create: `bin-talk-manager/scripts/database_scripts/table_messages.sql`
- Create: `bin-talk-manager/scripts/database_scripts/table_participants.sql`

**Step 1: Create table_talks.sql**

Content for `bin-talk-manager/scripts/database_scripts/table_talks.sql`:
```sql
-- SQLite-compatible schema for talk_chats table
-- Used for unit testing with in-memory SQLite database

CREATE TABLE talk_chats (
    id              BLOB PRIMARY KEY,
    customer_id     BLOB NOT NULL,
    type            TEXT NOT NULL,
    tm_create       TEXT NOT NULL,
    tm_update       TEXT NOT NULL,
    tm_delete       TEXT
);

CREATE INDEX idx_talk_chats_customer_id ON talk_chats(customer_id);
```

**Step 2: Create table_participants.sql**

Content for `bin-talk-manager/scripts/database_scripts/table_participants.sql`:
```sql
-- SQLite-compatible schema for talk_participants table

CREATE TABLE talk_participants (
    id              BLOB PRIMARY KEY,
    chat_id         BLOB NOT NULL,
    owner_type      TEXT NOT NULL,
    owner_id        BLOB NOT NULL,
    tm_joined       TEXT NOT NULL
);

CREATE INDEX idx_talk_participants_chat_id ON talk_participants(chat_id);
CREATE INDEX idx_talk_participants_owner ON talk_participants(owner_type, owner_id);
CREATE UNIQUE INDEX unique_participant ON talk_participants(chat_id, owner_type, owner_id);
```

**Step 3: Create table_messages.sql**

Content for `bin-talk-manager/scripts/database_scripts/table_messages.sql`:
```sql
-- SQLite-compatible schema for talk_messages table

CREATE TABLE talk_messages (
    id              BLOB PRIMARY KEY,
    customer_id     BLOB NOT NULL,
    chat_id         BLOB NOT NULL,
    parent_id       BLOB,
    owner_type      TEXT NOT NULL,
    owner_id        BLOB NOT NULL,
    type            TEXT NOT NULL,
    text            TEXT,
    medias          TEXT,
    metadata        TEXT,
    tm_create       TEXT NOT NULL,
    tm_update       TEXT NOT NULL,
    tm_delete       TEXT
);

CREATE INDEX idx_talk_messages_chat_id ON talk_messages(chat_id);
CREATE INDEX idx_talk_messages_parent_id ON talk_messages(parent_id);
CREATE INDEX idx_talk_messages_customer_id ON talk_messages(customer_id);
CREATE INDEX idx_talk_messages_owner ON talk_messages(owner_type, owner_id);
```

**Step 4: Verify files created**

Run:
```bash
ls -la bin-talk-manager/scripts/database_scripts/
```

Expected:
```
table_messages.sql
table_participants.sql
table_talks.sql
```

**Step 5: Commit**

```bash
git add bin-talk-manager/scripts/database_scripts/
git commit -m "feat(talk-manager): add SQLite test database schemas"
```

**Note:** These SQL files are used for unit testing database handlers with SQLite in-memory databases. They are simplified versions of the MySQL schema from Alembic migrations, adapted for SQLite compatibility (BINARY(16) → BLOB, DATETIME(6) → TEXT, JSON → TEXT).

---

### Task 1.5: Create Configuration Management

**Files:**
- Create: `bin-talk-manager/internal/config/config.go`

**Step 1: Write configuration struct**

Content for `bin-talk-manager/internal/config/config.go`:
```go
package config

import (
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

type Config struct {
	// Database
	DatabaseDSN string

	// RabbitMQ
	RabbitmqAddress    string
	RabbitQueueListen  string
	RabbitQueueEvent   string
	RabbitDelayQueue   string

	// Redis
	RedisAddress  string
	RedisPassword string
	RedisDatabase int

	// Prometheus
	PrometheusEndpoint      string
	PrometheusListenAddress string
}

func InitConfig(cmd *cobra.Command) *Config {
	cfg := &Config{}

	// Database
	cmd.Flags().String("database_dsn", "", "Database DSN")
	viper.BindPFlag("database_dsn", cmd.Flags().Lookup("database_dsn"))
	viper.SetDefault("database_dsn", "root:password@tcp(localhost:3306)/voipbin")

	// RabbitMQ
	cmd.Flags().String("rabbitmq_address", "", "RabbitMQ address")
	viper.BindPFlag("rabbitmq_address", cmd.Flags().Lookup("rabbitmq_address"))
	viper.SetDefault("rabbitmq_address", "amqp://guest:guest@localhost:5672/")

	cmd.Flags().String("rabbit_queue_listen", "", "RabbitMQ listen queue")
	viper.BindPFlag("rabbit_queue_listen", cmd.Flags().Lookup("rabbit_queue_listen"))
	viper.SetDefault("rabbit_queue_listen", "bin-manager.talk.request")

	cmd.Flags().String("rabbit_queue_event", "", "RabbitMQ event queue")
	viper.BindPFlag("rabbit_queue_event", cmd.Flags().Lookup("rabbit_queue_event"))
	viper.SetDefault("rabbit_queue_event", "bin-manager.talk.event")

	cmd.Flags().String("rabbit_delay_queue", "", "RabbitMQ delay queue")
	viper.BindPFlag("rabbit_delay_queue", cmd.Flags().Lookup("rabbit_delay_queue"))
	viper.SetDefault("rabbit_delay_queue", "bin-manager.delay")

	// Redis
	cmd.Flags().String("redis_address", "", "Redis address")
	viper.BindPFlag("redis_address", cmd.Flags().Lookup("redis_address"))
	viper.SetDefault("redis_address", "localhost:6379")

	cmd.Flags().String("redis_password", "", "Redis password")
	viper.BindPFlag("redis_password", cmd.Flags().Lookup("redis_password"))
	viper.SetDefault("redis_password", "")

	cmd.Flags().Int("redis_database", 0, "Redis database")
	viper.BindPFlag("redis_database", cmd.Flags().Lookup("redis_database"))
	viper.SetDefault("redis_database", 1)

	// Prometheus
	cmd.Flags().String("prometheus_endpoint", "", "Prometheus metrics endpoint")
	viper.BindPFlag("prometheus_endpoint", cmd.Flags().Lookup("prometheus_endpoint"))
	viper.SetDefault("prometheus_endpoint", "/metrics")

	cmd.Flags().String("prometheus_listen_address", "", "Prometheus listen address")
	viper.BindPFlag("prometheus_listen_address", cmd.Flags().Lookup("prometheus_listen_address"))
	viper.SetDefault("prometheus_listen_address", ":2112")

	// Read config
	viper.AutomaticEnv()

	cfg.DatabaseDSN = viper.GetString("database_dsn")
	cfg.RabbitmqAddress = viper.GetString("rabbitmq_address")
	cfg.RabbitQueueListen = viper.GetString("rabbit_queue_listen")
	cfg.RabbitQueueEvent = viper.GetString("rabbit_queue_event")
	cfg.RabbitDelayQueue = viper.GetString("rabbit_delay_queue")
	cfg.RedisAddress = viper.GetString("redis_address")
	cfg.RedisPassword = viper.GetString("redis_password")
	cfg.RedisDatabase = viper.GetInt("redis_database")
	cfg.PrometheusEndpoint = viper.GetString("prometheus_endpoint")
	cfg.PrometheusListenAddress = viper.GetString("prometheus_listen_address")

	return cfg
}
```

**Step 2: Commit**

```bash
git add internal/config/config.go
git commit -m "feat(talk-manager): add configuration management"
```

---

### Task 1.6: Create Main Entry Point

**Files:**
- Create: `bin-talk-manager/cmd/talk-manager/main.go`

**Step 1: Write main.go skeleton**

Content for `bin-talk-manager/cmd/talk-manager/main.go`:
```go
package main

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"monorepo/bin-talk-manager/internal/config"
	commondb "monorepo/bin-common-handler/pkg/databasehandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
)

var rootCmd = &cobra.Command{
	Use:   "talk-manager",
	Short: "Talk Manager Service",
	Long:  "Manages talks, messages, participants, and reactions",
	Run:   run,
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		log.Fatalf("Failed to execute command: %v", err)
	}
}

func run(cmd *cobra.Command, args []string) {
	// Initialize config
	cfg := config.InitConfig(cmd)
	log.Infof("Starting talk-manager service")

	// Initialize database
	db, err := commondb.InitDatabase(cfg.DatabaseDSN)
	if err != nil {
		log.Fatalf("Could not initialize database: %v", err)
	}
	defer db.Close()
	log.Infof("Database initialized")

	// Initialize RabbitMQ
	sockHandler, err := commonsock.InitSockHandler(
		cfg.RabbitmqAddress,
		cfg.RabbitQueueListen,
		cfg.RabbitQueueEvent,
		cfg.RabbitDelayQueue,
	)
	if err != nil {
		log.Fatalf("Could not initialize RabbitMQ: %v", err)
	}
	defer sockHandler.Terminate()
	log.Infof("RabbitMQ initialized")

	// Start Prometheus metrics server
	go func() {
		http.Handle(cfg.PrometheusEndpoint, promhttp.Handler())
		log.Infof("Prometheus metrics available at %s%s", cfg.PrometheusListenAddress, cfg.PrometheusEndpoint)
		if err := http.ListenAndServe(cfg.PrometheusListenAddress, nil); err != nil {
			log.Errorf("Prometheus server error: %v", err)
		}
	}()

	// TODO: Initialize handlers and start listening

	// Wait for interrupt signal
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	log.Infof("Shutting down talk-manager service")
}
```

**Step 2: Build to verify**

Run:
```bash
cd bin-talk-manager
go build ./cmd/talk-manager
```

Expected: Compiles successfully, creates `talk-manager` binary

**Step 3: Clean up binary**

Run: `rm talk-manager`

**Step 4: Commit**

```bash
git add cmd/talk-manager/main.go
git commit -m "feat(talk-manager): add main entry point with config and connections"
```

---

## Phase 2: Core Models & Database

### Task 2.1: Create Talk Model

**Files:**
- Create: `bin-talk-manager/models/talk/talk.go`
- Create: `bin-talk-manager/models/talk/field.go`

**Step 1: Write talk model**

Content for `bin-talk-manager/models/talk/talk.go`:
```go
package talk

import (
	"github.com/gofrs/uuid"
	commonidentity "monorepo/bin-common-handler/models/identity"
)

// Type constants
const (
	TypeNormal = "normal"
	TypeGroup  = "group"
)

type Type string

// Talk represents a talk session
type Talk struct {
	commonidentity.Identity

	Type Type `json:"type" db:"type"`

	// Timestamps
	TMCreate string `json:"tm_create" db:"tm_create"`
	TMUpdate string `json:"tm_update" db:"tm_update"`
	TMDelete string `json:"tm_delete" db:"tm_delete"`
}

// WebhookMessage is the webhook payload for talk events
type WebhookMessage struct {
	commonidentity.Identity

	Type     Type   `json:"type"`
	TMCreate string `json:"tm_create"`
	TMUpdate string `json:"tm_update"`
	TMDelete string `json:"tm_delete"`
}
```

**Step 2: Write field constants**

Content for `bin-talk-manager/models/talk/field.go`:
```go
package talk

import "github.com/gofrs/uuid"

// Field represents database field names for talk
type Field string

const (
	FieldID         Field = "id"
	FieldCustomerID Field = "customer_id"
	FieldType       Field = "type"
	FieldTMCreate   Field = "tm_create"
	FieldTMUpdate   Field = "tm_update"
	FieldTMDelete   Field = "tm_delete"
	FieldDeleted    Field = "deleted" // Filter-only field
)

// FieldStruct defines filterable fields with their types
type FieldStruct struct {
	ID         uuid.UUID `filter:"id"`
	CustomerID uuid.UUID `filter:"customer_id"`
	Type       string    `filter:"type"`
	Deleted    bool      `filter:"deleted"`
}

// GetDBFields returns list of database fields for SELECT queries
func GetDBFields() []string {
	return []string{
		"id",
		"customer_id",
		"type",
		"tm_create",
		"tm_update",
		"tm_delete",
	}
}
```

**Step 3: Commit**

```bash
git add models/talk/
git commit -m "feat(talk-manager): add talk model with field constants"
```

---

### Task 2.2: Create Participant Model

**Files:**
- Create: `bin-talk-manager/models/participant/participant.go`
- Create: `bin-talk-manager/models/participant/field.go`

**Step 1: Write participant model**

Content for `bin-talk-manager/models/participant/participant.go`:
```go
package participant

import (
	"github.com/gofrs/uuid"
	commonidentity "monorepo/bin-common-handler/models/identity"
)

// Participant represents a talk participant
type Participant struct {
	commonidentity.Identity
	commonidentity.Owner

	ChatID uuid.UUID `json:"chat_id" db:"chat_id,uuid"`

	// Timestamps
	TMJoined string `json:"tm_joined" db:"tm_joined"`
}

// WebhookMessage is the webhook payload for participant events
type WebhookMessage struct {
	commonidentity.Identity
	commonidentity.Owner

	ChatID   uuid.UUID `json:"chat_id"`
	TMJoined string    `json:"tm_joined"`
}
```

**Step 2: Write field constants**

Content for `bin-talk-manager/models/participant/field.go`:
```go
package participant

import "github.com/gofrs/uuid"

// Field represents database field names for participant
type Field string

const (
	FieldID         Field = "id"
	FieldCustomerID Field = "customer_id"
	FieldChatID     Field = "chat_id"
	FieldOwnerType  Field = "owner_type"
	FieldOwnerID    Field = "owner_id"
	FieldTMJoined   Field = "tm_joined"
)

// FieldStruct defines filterable fields with their types
type FieldStruct struct {
	ID         uuid.UUID `filter:"id"`
	CustomerID uuid.UUID `filter:"customer_id"`
	ChatID     uuid.UUID `filter:"chat_id"`
	OwnerType  string    `filter:"owner_type"`
	OwnerID    uuid.UUID `filter:"owner_id"`
}

// GetDBFields returns list of database fields for SELECT queries
func GetDBFields() []string {
	return []string{
		"id",
		"customer_id",
		"chat_id",
		"owner_type",
		"owner_id",
		"tm_joined",
	}
}
```

**Step 3: Commit**

```bash
git add models/participant/
git commit -m "feat(talk-manager): add participant model with field constants"
```

---

### Task 2.3: Create Message Model

**Files:**
- Create: `bin-talk-manager/models/message/message.go`
- Create: `bin-talk-manager/models/message/field.go`
- Create: `bin-talk-manager/models/message/metadata.go`

**Step 1: Write message model**

Content for `bin-talk-manager/models/message/message.go`:
```go
package message

import (
	"github.com/gofrs/uuid"
	commonidentity "monorepo/bin-common-handler/models/identity"
)

// Type constants
const (
	TypeNormal = "normal"
	TypeSystem = "system"
)

type Type string

// Message represents a talk message
type Message struct {
	commonidentity.Identity
	commonidentity.Owner

	ChatID   uuid.UUID  `json:"chat_id" db:"chat_id,uuid"`
	ParentID *uuid.UUID `json:"parent_id,omitempty" db:"parent_id,uuid"`

	Type     Type   `json:"type" db:"type"`
	Text     string `json:"text" db:"text"`
	Medias   string `json:"medias" db:"medias"`   // JSON string
	Metadata string `json:"metadata" db:"metadata"` // JSON string

	// Timestamps
	TMCreate string `json:"tm_create" db:"tm_create"`
	TMUpdate string `json:"tm_update" db:"tm_update"`
	TMDelete string `json:"tm_delete" db:"tm_delete"`
}

// WebhookMessage is the webhook payload for message events
type WebhookMessage struct {
	commonidentity.Identity
	commonidentity.Owner

	ChatID   uuid.UUID  `json:"chat_id"`
	ParentID *uuid.UUID `json:"parent_id,omitempty"`

	Type     Type     `json:"type"`
	Text     string   `json:"text"`
	Medias   []Media  `json:"medias"`
	Metadata Metadata `json:"metadata"`

	TMCreate string `json:"tm_create"`
	TMUpdate string `json:"tm_update"`
	TMDelete string `json:"tm_delete"`
}

// Media represents a media attachment (simplified from chat-manager)
type Media struct {
	Type string `json:"type"` // "file", "link", "address", "agent"
	// Add specific fields as needed based on Type
}
```

**Step 2: Write metadata model**

Content for `bin-talk-manager/models/message/metadata.go`:
```go
package message

import "github.com/gofrs/uuid"

// Metadata represents message metadata (reactions, etc.)
type Metadata struct {
	Reactions []Reaction `json:"reactions"`
}

// Reaction represents a single emoji reaction
type Reaction struct {
	Emoji     string    `json:"emoji"`
	OwnerType string    `json:"owner_type"`
	OwnerID   uuid.UUID `json:"owner_id"`
	TMCreate  string    `json:"tm_create"`
}
```

**Step 3: Write field constants**

Content for `bin-talk-manager/models/message/field.go`:
```go
package message

import "github.com/gofrs/uuid"

// Field represents database field names for message
type Field string

const (
	FieldID         Field = "id"
	FieldCustomerID Field = "customer_id"
	FieldChatID     Field = "chat_id"
	FieldParentID   Field = "parent_id"
	FieldOwnerType  Field = "owner_type"
	FieldOwnerID    Field = "owner_id"
	FieldType       Field = "type"
	FieldText       Field = "text"
	FieldMedias     Field = "medias"
	FieldMetadata   Field = "metadata"
	FieldTMCreate   Field = "tm_create"
	FieldTMUpdate   Field = "tm_update"
	FieldTMDelete   Field = "tm_delete"
	FieldDeleted    Field = "deleted" // Filter-only field
)

// FieldStruct defines filterable fields with their types
type FieldStruct struct {
	ID         uuid.UUID  `filter:"id"`
	CustomerID uuid.UUID  `filter:"customer_id"`
	ChatID     uuid.UUID  `filter:"chat_id"`
	ParentID   *uuid.UUID `filter:"parent_id"`
	OwnerType  string     `filter:"owner_type"`
	OwnerID    uuid.UUID  `filter:"owner_id"`
	Deleted    bool       `filter:"deleted"`
}

// GetDBFields returns list of database fields for SELECT queries
func GetDBFields() []string {
	return []string{
		"id",
		"customer_id",
		"chat_id",
		"parent_id",
		"owner_type",
		"owner_id",
		"type",
		"text",
		"medias",
		"metadata",
		"tm_create",
		"tm_update",
		"tm_delete",
	}
}
```

**Step 4: Commit**

```bash
git add models/message/
git commit -m "feat(talk-manager): add message model with metadata and field constants"
```

---

### Task 2.4: Create Database Handler Interface

**Files:**
- Create: `bin-talk-manager/pkg/dbhandler/main.go`

**Step 1: Write dbhandler interface**

Content for `bin-talk-manager/pkg/dbhandler/main.go`:
```go
//go:generate mockgen -package dbhandler -destination ./mock_main.go -source main.go -build_flags=-mod=mod

package dbhandler

import (
	"context"
	"database/sql"

	"github.com/go-redis/redis/v8"
	"github.com/gofrs/uuid"

	"monorepo/bin-talk-manager/models/message"
	"monorepo/bin-talk-manager/models/participant"
	"monorepo/bin-talk-manager/models/talk"
)

// DBHandler defines database operations interface
type DBHandler interface {
	// Talk operations
	TalkCreate(ctx context.Context, t *talk.Talk) error
	TalkGet(ctx context.Context, id uuid.UUID) (*talk.Talk, error)
	TalkList(ctx context.Context, filters map[talk.Field]any, token string, size uint64) ([]*talk.Talk, error)
	TalkUpdate(ctx context.Context, id uuid.UUID, fields map[talk.Field]any) error
	TalkDelete(ctx context.Context, id uuid.UUID) error

	// Participant operations
	ParticipantCreate(ctx context.Context, p *participant.Participant) error
	ParticipantGet(ctx context.Context, id uuid.UUID) (*participant.Participant, error)
	ParticipantList(ctx context.Context, filters map[participant.Field]any) ([]*participant.Participant, error)
	ParticipantDelete(ctx context.Context, id uuid.UUID) error

	// Message operations
	MessageCreate(ctx context.Context, m *message.Message) error
	MessageGet(ctx context.Context, id uuid.UUID) (*message.Message, error)
	MessageList(ctx context.Context, filters map[message.Field]any, token string, size uint64) ([]*message.Message, error)
	MessageUpdate(ctx context.Context, id uuid.UUID, fields map[message.Field]any) error
	MessageDelete(ctx context.Context, id uuid.UUID) error

	// Atomic reaction operations (prevents race conditions)
	MessageAddReactionAtomic(ctx context.Context, messageID uuid.UUID, reactionJSON string) error
	MessageRemoveReactionAtomic(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) error
}

// dbHandler implements DBHandler
type dbHandler struct {
	db    *sql.DB
	redis *redis.Client
}

// New creates a new DBHandler
func New(db *sql.DB, redisClient *redis.Client) DBHandler {
	return &dbHandler{
		db:    db,
		redis: redisClient,
	}
}
```

**Step 2: Generate mocks**

Run:
```bash
cd bin-talk-manager/pkg/dbhandler
go generate
```

Expected: Creates `mock_main.go`

**Step 3: Commit**

```bash
git add pkg/dbhandler/
git commit -m "feat(talk-manager): add database handler interface"
```

---

### Task 2.5: Implement Talk Database Operations

**Files:**
- Create: `bin-talk-manager/pkg/dbhandler/talk.go`
- Create: `bin-talk-manager/pkg/dbhandler/talk_test.go`

**Step 1: Write failing test**

Content for `bin-talk-manager/pkg/dbhandler/talk_test.go`:
```go
package dbhandler

import (
	"context"
	"testing"

	"github.com/gofrs/uuid"
	"monorepo/bin-talk-manager/models/talk"
)

func TestTalkCreate(t *testing.T) {
	// TODO: Add table-driven tests
	ctx := context.Background()
	handler := &dbHandler{}

	testTalk := &talk.Talk{
		Identity: commonidentity.Identity{
			ID:         uuid.Must(uuid.NewV4()),
			CustomerID: uuid.Must(uuid.NewV4()),
		},
		Type: talk.TypeNormal,
	}

	err := handler.TalkCreate(ctx, testTalk)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
}
```

**Step 2: Run test to verify it fails**

Run: `cd bin-talk-manager && go test ./pkg/dbhandler -v -run TestTalkCreate`
Expected: FAIL (not implemented)

**Step 3: Implement TalkCreate**

Content for `bin-talk-manager/pkg/dbhandler/talk.go`:
```go
package dbhandler

import (
	"context"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commondb "monorepo/bin-common-handler/pkg/commondatabasehandler"
	"monorepo/bin-talk-manager/models/talk"
)

const tableTalks = "talk_chats"

func (h *dbHandler) TalkCreate(ctx context.Context, t *talk.Talk) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	t.TMCreate = now
	t.TMUpdate = now

	fields := commondb.PrepareFields(t, []string{"tm_create", "tm_update"})

	query := sq.Insert(tableTalks).
		SetMap(fields).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		log.Errorf("Failed to build query: %v", err)
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		log.Errorf("Failed to create talk: %v", err)
		return err
	}

	return nil
}

func (h *dbHandler) TalkGet(ctx context.Context, id uuid.UUID) (*talk.Talk, error) {
	query := sq.Select(talk.GetDBFields()...).
		From(tableTalks).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	var t talk.Talk
	row := h.db.QueryRowContext(ctx, sqlQuery, args...)
	err = commondb.ScanRow(row, &t)
	if err != nil {
		return nil, err
	}

	return &t, nil
}

func (h *dbHandler) TalkList(ctx context.Context, filters map[talk.Field]any, token string, size uint64) ([]*talk.Talk, error) {
	query := sq.Select(talk.GetDBFields()...).
		From(tableTalks).
		OrderBy("tm_create DESC").
		Limit(size).
		PlaceholderFormat(sq.Question)

	// Apply filters
	query = commondb.ApplyFields(query, filters, map[string]bool{
		"deleted": true, // Filter-only field
	})

	// Apply pagination token
	if token != "" {
		query = query.Where(sq.Lt{"tm_create": token})
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := h.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var talks []*talk.Talk
	for rows.Next() {
		var t talk.Talk
		err = commondb.ScanRow(rows, &t)
		if err != nil {
			return nil, err
		}
		talks = append(talks, &t)
	}

	return talks, nil
}

func (h *dbHandler) TalkUpdate(ctx context.Context, id uuid.UUID, fields map[talk.Field]any) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	fields[talk.FieldTMUpdate] = now

	query := sq.Update(tableTalks).
		SetMap(fields).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	return err
}

func (h *dbHandler) TalkDelete(ctx context.Context, id uuid.UUID) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")

	query := sq.Update(tableTalks).
		Set("tm_delete", now).
		Set("tm_update", now).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	return err
}
```

**Step 4: Run test (will still fail without database)**

Run: `cd bin-talk-manager && go test ./pkg/dbhandler -v -run TestTalkCreate`
Expected: Compiles but fails (no database connection)

**Step 5: Commit**

```bash
git add pkg/dbhandler/talk.go pkg/dbhandler/talk_test.go
git commit -m "feat(talk-manager): implement talk database operations"
```

---

### Task 2.6: Implement Participant Database Operations

**Files:**
- Create: `bin-talk-manager/pkg/dbhandler/participant.go`

**Step 1: Implement participant operations**

Content for `bin-talk-manager/pkg/dbhandler/participant.go`:
```go
package dbhandler

import (
	"context"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commondb "monorepo/bin-common-handler/pkg/commondatabasehandler"
	"monorepo/bin-talk-manager/models/participant"
)

const tableParticipants = "talk_participants"

func (h *dbHandler) ParticipantCreate(ctx context.Context, p *participant.Participant) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	p.TMJoined = now

	// Use UPSERT to handle re-joins (participant leaves and joins again)
	// ON DUPLICATE KEY UPDATE prevents unique constraint violations
	query := `
		INSERT INTO talk_participants
		(id, customer_id, chat_id, owner_type, owner_id, tm_joined)
		VALUES (?, ?, ?, ?, ?, ?)
		ON DUPLICATE KEY UPDATE
		tm_joined = VALUES(tm_joined)
	`

	_, err := h.db.ExecContext(ctx, query,
		p.ID.Bytes(),
		p.CustomerID.Bytes(),
		p.ChatID.Bytes(),
		p.OwnerType,
		p.OwnerID.Bytes(),
		now,
	)

	if err != nil {
		log.Errorf("Failed to create/update participant: %v", err)
		return err
	}

	return nil
}

func (h *dbHandler) ParticipantGet(ctx context.Context, id uuid.UUID) (*participant.Participant, error) {
	query := sq.Select(participant.GetDBFields()...).
		From(tableParticipants).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	var p participant.Participant
	row := h.db.QueryRowContext(ctx, sqlQuery, args...)
	err = commondb.ScanRow(row, &p)
	if err != nil {
		return nil, err
	}

	return &p, nil
}

func (h *dbHandler) ParticipantList(ctx context.Context, filters map[participant.Field]any) ([]*participant.Participant, error) {
	query := sq.Select(participant.GetDBFields()...).
		From(tableParticipants).
		OrderBy("tm_joined DESC").
		PlaceholderFormat(sq.Question)

	// Apply filters
	query = commondb.ApplyFields(query, filters, nil)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := h.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var participants []*participant.Participant
	for rows.Next() {
		var p participant.Participant
		err = commondb.ScanRow(rows, &p)
		if err != nil {
			return nil, err
		}
		participants = append(participants, &p)
	}

	return participants, nil
}

func (h *dbHandler) ParticipantDelete(ctx context.Context, id uuid.UUID) error {
	query := sq.Delete(tableParticipants).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	return err
}
```

**Step 2: Commit**

```bash
git add pkg/dbhandler/participant.go
git commit -m "feat(talk-manager): implement participant database operations"
```

---

### Task 2.7: Implement Message Database Operations

**Files:**
- Create: `bin-talk-manager/pkg/dbhandler/message.go`

**Step 1: Implement message operations**

Content for `bin-talk-manager/pkg/dbhandler/message.go`:
```go
package dbhandler

import (
	"context"
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commondb "monorepo/bin-common-handler/pkg/commondatabasehandler"
	"monorepo/bin-talk-manager/models/message"
)

const tableMessages = "talk_messages"

func (h *dbHandler) MessageCreate(ctx context.Context, m *message.Message) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	m.TMCreate = now
	m.TMUpdate = now

	// Initialize empty metadata if not set
	if m.Metadata == "" {
		m.Metadata = `{"reactions":[]}`
	}

	fields := commondb.PrepareFields(m, []string{"tm_create", "tm_update"})

	query := sq.Insert(tableMessages).
		SetMap(fields).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		log.Errorf("Failed to build query: %v", err)
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	if err != nil {
		log.Errorf("Failed to create message: %v", err)
		return err
	}

	return nil
}

func (h *dbHandler) MessageGet(ctx context.Context, id uuid.UUID) (*message.Message, error) {
	query := sq.Select(message.GetDBFields()...).
		From(tableMessages).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	var m message.Message
	row := h.db.QueryRowContext(ctx, sqlQuery, args...)
	err = commondb.ScanRow(row, &m)
	if err != nil {
		return nil, err
	}

	return &m, nil
}

func (h *dbHandler) MessageList(ctx context.Context, filters map[message.Field]any, token string, size uint64) ([]*message.Message, error) {
	query := sq.Select(message.GetDBFields()...).
		From(tableMessages).
		OrderBy("tm_create DESC").
		Limit(size).
		PlaceholderFormat(sq.Question)

	// Apply filters
	query = commondb.ApplyFields(query, filters, map[string]bool{
		"deleted": true, // Filter-only field
	})

	// Apply pagination token
	if token != "" {
		query = query.Where(sq.Lt{"tm_create": token})
	}

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	rows, err := h.db.QueryContext(ctx, sqlQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var messages []*message.Message
	for rows.Next() {
		var m message.Message
		err = commondb.ScanRow(rows, &m)
		if err != nil {
			return nil, err
		}
		messages = append(messages, &m)
	}

	return messages, nil
}

func (h *dbHandler) MessageUpdate(ctx context.Context, id uuid.UUID, fields map[message.Field]any) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	fields[message.FieldTMUpdate] = now

	query := sq.Update(tableMessages).
		SetMap(fields).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	return err
}

func (h *dbHandler) MessageDelete(ctx context.Context, id uuid.UUID) error {
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")

	query := sq.Update(tableMessages).
		Set("tm_delete", now).
		Set("tm_update", now).
		Where(sq.Eq{"id": id.Bytes()}).
		PlaceholderFormat(sq.Question)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return err
	}

	_, err = h.db.ExecContext(ctx, sqlQuery, args...)
	return err
}

// MessageAddReactionAtomic atomically adds a reaction using MySQL JSON functions
// This prevents race conditions when multiple users add reactions simultaneously
func (h *dbHandler) MessageAddReactionAtomic(ctx context.Context, messageID uuid.UUID, reactionJSON string) error {
	query := `
		UPDATE talk_messages
		SET metadata = JSON_SET(
			metadata,
			'$.reactions',
			JSON_ARRAY_APPEND(
				JSON_EXTRACT(metadata, '$.reactions'),
				'$',
				CAST(? AS JSON)
			)
		),
		tm_update = ?
		WHERE id = ?
	`

	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	_, err := h.db.ExecContext(ctx, query, reactionJSON, now, messageID.Bytes())
	if err != nil {
		log.Errorf("Failed to add reaction atomically: %v", err)
		return err
	}

	return nil
}

// MessageRemoveReactionAtomic atomically removes a reaction by filtering the JSON array
func (h *dbHandler) MessageRemoveReactionAtomic(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) error {
	// Get current metadata
	var metadataJSON string
	err := h.db.QueryRowContext(ctx,
		"SELECT metadata FROM talk_messages WHERE id = ?",
		messageID.Bytes(),
	).Scan(&metadataJSON)
	if err != nil {
		return err
	}

	// Parse and filter reactions
	var metadata message.Metadata
	json.Unmarshal([]byte(metadataJSON), &metadata)

	var filtered []message.Reaction
	for _, r := range metadata.Reactions {
		if !(r.Emoji == emoji && r.OwnerType == ownerType && r.OwnerID == ownerID) {
			filtered = append(filtered, r)
		}
	}

	// Update with filtered reactions atomically
	filteredJSON, _ := json.Marshal(filtered)
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")

	query := `
		UPDATE talk_messages
		SET metadata = JSON_SET(metadata, '$.reactions', CAST(? AS JSON)),
		    tm_update = ?
		WHERE id = ?
	`

	_, err = h.db.ExecContext(ctx, query, string(filteredJSON), now, messageID.Bytes())
	if err != nil {
		log.Errorf("Failed to remove reaction atomically: %v", err)
		return err
	}

	return nil
}
```

**Step 2: Add import for encoding/json**

The atomic reaction methods need the `encoding/json` package. Update imports at the top of the file:
```go
import (
	"context"
	"encoding/json"  // Add this line
	"time"

	sq "github.com/Masterminds/squirrel"
	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commondb "monorepo/bin-common-handler/pkg/commondatabasehandler"
	"monorepo/bin-talk-manager/models/message"
)
```

**Step 3: Commit**

```bash
git add pkg/dbhandler/message.go
git commit -m "feat(talk-manager): implement message database operations"
```

---

## Phase 3: Business Logic Handlers

### Task 3.1: Create Talk Handler

**Files:**
- Create: `bin-talk-manager/pkg/talkhandler/main.go`
- Create: `bin-talk-manager/pkg/talkhandler/talk.go`

**Step 1: Write handler interface**

Content for `bin-talk-manager/pkg/talkhandler/main.go`:
```go
//go:generate mockgen -package talkhandler -destination ./mock_main.go -source main.go -build_flags=-mod=mod

package talkhandler

import (
	"context"

	"github.com/gofrs/uuid"

	"monorepo/bin-talk-manager/models/talk"
	"monorepo/bin-talk-manager/pkg/dbhandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
	commonnotify "monorepo/bin-common-handler/pkg/notifyhandler"
)

// TalkHandler defines business logic for talks
type TalkHandler interface {
	TalkCreate(ctx context.Context, customerID uuid.UUID, talkType talk.Type) (*talk.Talk, error)
	TalkGet(ctx context.Context, id uuid.UUID) (*talk.Talk, error)
	TalkList(ctx context.Context, filters map[talk.Field]any, token string, size uint64) ([]*talk.Talk, error)
	TalkDelete(ctx context.Context, id uuid.UUID) (*talk.Talk, error)
}

type talkHandler struct {
	dbHandler     dbhandler.DBHandler
	sockHandler   commonsock.SockHandler
	notifyHandler commonnotify.NotifyHandler
}

// New creates a new TalkHandler
func New(db dbhandler.DBHandler, sock commonsock.SockHandler) TalkHandler {
	return &talkHandler{
		dbHandler:     db,
		sockHandler:   sock,
		notifyHandler: commonnotify.New(sock),
	}
}
```

**Step 2: Implement talk operations**

Content for `bin-talk-manager/pkg/talkhandler/talk.go`:
```go
package talkhandler

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commonidentity "monorepo/bin-common-handler/models/identity"
	"monorepo/bin-talk-manager/models/talk"
)

func (h *talkHandler) TalkCreate(ctx context.Context, customerID uuid.UUID, talkType talk.Type) (*talk.Talk, error) {
	t := &talk.Talk{
		Identity: commonidentity.Identity{
			ID:         uuid.Must(uuid.NewV4()),
			CustomerID: customerID,
		},
		Type: talkType,
	}

	err := h.dbHandler.TalkCreate(ctx, t)
	if err != nil {
		log.Errorf("Failed to create talk: %v", err)
		return nil, err
	}

	// Publish webhook event
	webhookMsg := talk.WebhookMessage{
		Identity: t.Identity,
		Type:     t.Type,
		TMCreate: t.TMCreate,
		TMUpdate: t.TMUpdate,
		TMDelete: t.TMDelete,
	}
	h.notifyHandler.PublishWebhook("talk_created", webhookMsg)

	return t, nil
}

func (h *talkHandler) TalkGet(ctx context.Context, id uuid.UUID) (*talk.Talk, error) {
	return h.dbHandler.TalkGet(ctx, id)
}

func (h *talkHandler) TalkList(ctx context.Context, filters map[talk.Field]any, token string, size uint64) ([]*talk.Talk, error) {
	return h.dbHandler.TalkList(ctx, filters, token, size)
}

func (h *talkHandler) TalkDelete(ctx context.Context, id uuid.UUID) (*talk.Talk, error) {
	// Get talk before deleting (for webhook)
	t, err := h.dbHandler.TalkGet(ctx, id)
	if err != nil {
		return nil, err
	}

	// Soft delete
	err = h.dbHandler.TalkDelete(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get updated talk with tm_delete
	t, _ = h.dbHandler.TalkGet(ctx, id)

	// Publish webhook event
	webhookMsg := talk.WebhookMessage{
		Identity: t.Identity,
		Type:     t.Type,
		TMCreate: t.TMCreate,
		TMUpdate: t.TMUpdate,
		TMDelete: t.TMDelete,
	}
	h.notifyHandler.PublishWebhook("talk_deleted", webhookMsg)

	return t, nil
}
```

**Step 3: Generate mocks**

Run:
```bash
cd bin-talk-manager/pkg/talkhandler
go generate
```

**Step 4: Commit**

```bash
git add pkg/talkhandler/
git commit -m "feat(talk-manager): add talk business logic handler"
```

---

### Task 3.2: Create Message Handler with Threading Validation

**Files:**
- Create: `bin-talk-manager/pkg/messagehandler/main.go`
- Create: `bin-talk-manager/pkg/messagehandler/message.go`

**Step 1: Write handler interface**

Content for `bin-talk-manager/pkg/messagehandler/main.go`:
```go
//go:generate mockgen -package messagehandler -destination ./mock_main.go -source main.go -build_flags=-mod=mod

package messagehandler

import (
	"context"

	"github.com/gofrs/uuid"

	"monorepo/bin-talk-manager/models/message"
	"monorepo/bin-talk-manager/pkg/dbhandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
	commonnotify "monorepo/bin-common-handler/pkg/notifyhandler"
)

// MessageHandler defines business logic for messages
type MessageHandler interface {
	MessageCreate(ctx context.Context, req MessageCreateRequest) (*message.Message, error)
	MessageGet(ctx context.Context, id uuid.UUID) (*message.Message, error)
	MessageList(ctx context.Context, filters map[message.Field]any, token string, size uint64) ([]*message.Message, error)
	MessageDelete(ctx context.Context, id uuid.UUID) (*message.Message, error)
}

// MessageCreateRequest represents message creation request
type MessageCreateRequest struct {
	CustomerID uuid.UUID
	ChatID     uuid.UUID
	ParentID   *uuid.UUID
	OwnerType  string
	OwnerID    uuid.UUID
	Type       message.Type
	Text       string
	Medias     string // JSON string
}

type messageHandler struct {
	dbHandler     dbhandler.DBHandler
	sockHandler   commonsock.SockHandler
	notifyHandler commonnotify.NotifyHandler
}

// New creates a new MessageHandler
func New(db dbhandler.DBHandler, sock commonsock.SockHandler) MessageHandler {
	return &messageHandler{
		dbHandler:     db,
		sockHandler:   sock,
		notifyHandler: commonnotify.New(sock),
	}
}
```

**Step 2: Implement message operations with parent validation**

Content for `bin-talk-manager/pkg/messagehandler/message.go`:
```go
package messagehandler

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commonidentity "monorepo/bin-common-handler/models/identity"
	"monorepo/bin-talk-manager/models/message"
	"monorepo/bin-talk-manager/models/participant"
)

func (h *messageHandler) MessageCreate(ctx context.Context, req MessageCreateRequest) (*message.Message, error) {
	// Validate sender is a participant
	filters := map[participant.Field]any{
		participant.FieldChatID:    req.ChatID,
		participant.FieldOwnerType: req.OwnerType,
		participant.FieldOwnerID:   req.OwnerID,
	}
	participants, err := h.dbHandler.ParticipantList(ctx, filters)
	if err != nil || len(participants) == 0 {
		log.Errorf("Sender is not a participant in talk: %v", err)
		return nil, errors.New("sender must be a participant in the talk")
	}

	// Validate parent message if provided
	if req.ParentID != nil {
		parent, err := h.dbHandler.MessageGet(ctx, *req.ParentID)
		if err != nil {
			log.Errorf("Parent message not found: %v", err)
			return nil, errors.New("parent message does not exist")
		}

		// VALIDATION POLICY: Two checks required

		// 1. Parent must exist in database
		//    (Already validated above - MessageGet would fail if not found)

		// 2. Parent must be in same talk (prevents cross-talk threading)
		if parent.ChatID != req.ChatID {
			log.Errorf("Parent message is in different chat")
			return nil, errors.New("parent message must be in the same talk")
		}

		// INTENTIONALLY ALLOWED: Parent can be soft-deleted (tm_delete IS NOT NULL)
		// Reason: Preserve thread structure even when parent messages are deleted
		// UI should display deleted parent as placeholder (e.g., "Message deleted")
		// This allows conversation context to remain intact
		//
		// We do NOT check parent.TMDelete here - replies to deleted parents are allowed

		log.Debugf("Parent validation passed: id=%v, same_chat=%v, is_deleted=%v",
			parent.ID,
			parent.ChatID == req.ChatID,
			parent.TMDelete != "",
		)
	}

	// Create message
	m := &message.Message{
		Identity: commonidentity.Identity{
			ID:         uuid.Must(uuid.NewV4()),
			CustomerID: req.CustomerID,
		},
		Owner: commonidentity.Owner{
			OwnerType: req.OwnerType,
			OwnerID:   req.OwnerID,
		},
		ChatID:   req.ChatID,
		ParentID: req.ParentID,
		Type:     req.Type,
		Text:     req.Text,
		Medias:   req.Medias,
		Metadata: `{"reactions":[]}`,
	}

	err = h.dbHandler.MessageCreate(ctx, m)
	if err != nil {
		log.Errorf("Failed to create message: %v", err)
		return nil, err
	}

	// Publish webhook event
	var medias []message.Media
	json.Unmarshal([]byte(m.Medias), &medias)

	var metadata message.Metadata
	json.Unmarshal([]byte(m.Metadata), &metadata)

	webhookMsg := message.WebhookMessage{
		Identity: m.Identity,
		Owner:    m.Owner,
		ChatID:   m.ChatID,
		ParentID: m.ParentID,
		Type:     m.Type,
		Text:     m.Text,
		Medias:   medias,
		Metadata: metadata,
		TMCreate: m.TMCreate,
		TMUpdate: m.TMUpdate,
		TMDelete: m.TMDelete,
	}
	h.notifyHandler.PublishWebhook("message_created", webhookMsg)

	return m, nil
}

func (h *messageHandler) MessageGet(ctx context.Context, id uuid.UUID) (*message.Message, error) {
	return h.dbHandler.MessageGet(ctx, id)
}

func (h *messageHandler) MessageList(ctx context.Context, filters map[message.Field]any, token string, size uint64) ([]*message.Message, error) {
	return h.dbHandler.MessageList(ctx, filters, token, size)
}

func (h *messageHandler) MessageDelete(ctx context.Context, id uuid.UUID) (*message.Message, error) {
	// Get message before deleting (for webhook)
	m, err := h.dbHandler.MessageGet(ctx, id)
	if err != nil {
		return nil, err
	}

	// Soft delete
	err = h.dbHandler.MessageDelete(ctx, id)
	if err != nil {
		return nil, err
	}

	// Get updated message with tm_delete
	m, _ = h.dbHandler.MessageGet(ctx, id)

	// Publish webhook event
	var medias []message.Media
	json.Unmarshal([]byte(m.Medias), &medias)

	var metadata message.Metadata
	json.Unmarshal([]byte(m.Metadata), &metadata)

	webhookMsg := message.WebhookMessage{
		Identity: m.Identity,
		Owner:    m.Owner,
		ChatID:   m.ChatID,
		ParentID: m.ParentID,
		Type:     m.Type,
		Text:     m.Text,
		Medias:   medias,
		Metadata: metadata,
		TMCreate: m.TMCreate,
		TMUpdate: m.TMUpdate,
		TMDelete: m.TMDelete,
	}
	h.notifyHandler.PublishWebhook("message_deleted", webhookMsg)

	return m, nil
}
```

**Step 3: Generate mocks**

Run:
```bash
cd bin-talk-manager/pkg/messagehandler
go generate
```

**Step 4: Commit**

```bash
git add pkg/messagehandler/
git commit -m "feat(talk-manager): add message handler with threading validation"
```

---

### Task 3.3: Create Participant Handler

**Files:**
- Create: `bin-talk-manager/pkg/participanthandler/main.go`
- Create: `bin-talk-manager/pkg/participanthandler/participant.go`

**Step 1: Write handler interface**

Content for `bin-talk-manager/pkg/participanthandler/main.go`:
```go
//go:generate mockgen -package participanthandler -destination ./mock_main.go -source main.go -build_flags=-mod=mod

package participanthandler

import (
	"context"

	"github.com/gofrs/uuid"

	"monorepo/bin-talk-manager/models/participant"
	"monorepo/bin-talk-manager/pkg/dbhandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
	commonnotify "monorepo/bin-common-handler/pkg/notifyhandler"
)

// ParticipantHandler defines business logic for participants
type ParticipantHandler interface {
	ParticipantAdd(ctx context.Context, customerID, chatID uuid.UUID, ownerType string, ownerID uuid.UUID) (*participant.Participant, error)
	ParticipantList(ctx context.Context, chatID uuid.UUID) ([]*participant.Participant, error)
	ParticipantRemove(ctx context.Context, id uuid.UUID) error
}

type participantHandler struct {
	dbHandler     dbhandler.DBHandler
	sockHandler   commonsock.SockHandler
	notifyHandler commonnotify.NotifyHandler
}

// New creates a new ParticipantHandler
func New(db dbhandler.DBHandler, sock commonsock.SockHandler) ParticipantHandler {
	return &participantHandler{
		dbHandler:     db,
		sockHandler:   sock,
		notifyHandler: commonnotify.New(sock),
	}
}
```

**Step 2: Implement participant operations**

Content for `bin-talk-manager/pkg/participanthandler/participant.go`:
```go
package participanthandler

import (
	"context"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commonidentity "monorepo/bin-common-handler/models/identity"
	"monorepo/bin-talk-manager/models/participant"
)

func (h *participantHandler) ParticipantAdd(ctx context.Context, customerID, chatID uuid.UUID, ownerType string, ownerID uuid.UUID) (*participant.Participant, error) {
	p := &participant.Participant{
		Identity: commonidentity.Identity{
			ID:         uuid.Must(uuid.NewV4()),
			CustomerID: customerID,
		},
		Owner: commonidentity.Owner{
			OwnerType: ownerType,
			OwnerID:   ownerID,
		},
		ChatID: chatID,
	}

	err := h.dbHandler.ParticipantCreate(ctx, p)
	if err != nil {
		log.Errorf("Failed to add participant: %v", err)
		return nil, err
	}

	// Publish webhook event
	webhookMsg := participant.WebhookMessage{
		Identity: p.Identity,
		Owner:    p.Owner,
		ChatID:   p.ChatID,
		TMJoined: p.TMJoined,
	}
	h.notifyHandler.PublishWebhook("participant_added", webhookMsg)

	return p, nil
}

func (h *participantHandler) ParticipantList(ctx context.Context, chatID uuid.UUID) ([]*participant.Participant, error) {
	filters := map[participant.Field]any{
		participant.FieldChatID: chatID,
	}
	return h.dbHandler.ParticipantList(ctx, filters)
}

func (h *participantHandler) ParticipantRemove(ctx context.Context, id uuid.UUID) error {
	// Get participant before deleting (for webhook)
	p, err := h.dbHandler.ParticipantGet(ctx, id)
	if err != nil {
		return err
	}

	// Hard delete
	err = h.dbHandler.ParticipantDelete(ctx, id)
	if err != nil {
		return err
	}

	// Publish webhook event
	webhookMsg := participant.WebhookMessage{
		Identity: p.Identity,
		Owner:    p.Owner,
		ChatID:   p.ChatID,
		TMJoined: p.TMJoined,
	}
	h.notifyHandler.PublishWebhook("participant_removed", webhookMsg)

	return nil
}
```

**Step 3: Generate mocks**

Run:
```bash
cd bin-talk-manager/pkg/participanthandler
go generate
```

**Step 4: Commit**

```bash
git add pkg/participanthandler/
git commit -m "feat(talk-manager): add participant business logic handler"
```

---

### Task 3.4: Create Reaction Handler

**Files:**
- Create: `bin-talk-manager/pkg/reactionhandler/main.go`
- Create: `bin-talk-manager/pkg/reactionhandler/reaction.go`

**Step 1: Write handler interface**

Content for `bin-talk-manager/pkg/reactionhandler/main.go`:
```go
//go:generate mockgen -package reactionhandler -destination ./mock_main.go -source main.go -build_flags=-mod=mod

package reactionhandler

import (
	"context"

	"github.com/gofrs/uuid"

	"monorepo/bin-talk-manager/models/message"
	"monorepo/bin-talk-manager/pkg/dbhandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
	commonnotify "monorepo/bin-common-handler/pkg/notifyhandler"
)

// ReactionHandler defines business logic for reactions
type ReactionHandler interface {
	ReactionAdd(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) (*message.Message, error)
	ReactionRemove(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) (*message.Message, error)
}

type reactionHandler struct {
	dbHandler     dbhandler.DBHandler
	sockHandler   commonsock.SockHandler
	notifyHandler commonnotify.NotifyHandler
}

// New creates a new ReactionHandler
func New(db dbhandler.DBHandler, sock commonsock.SockHandler) ReactionHandler {
	return &reactionHandler{
		dbHandler:     db,
		sockHandler:   sock,
		notifyHandler: commonnotify.New(sock),
	}
}
```

**Step 2: Implement reaction operations**

Content for `bin-talk-manager/pkg/reactionhandler/reaction.go`:
```go
package reactionhandler

import (
	"context"
	"encoding/json"
	"time"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	"monorepo/bin-talk-manager/models/message"
)

func (h *reactionHandler) ReactionAdd(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) (*message.Message, error) {
	// Check if reaction already exists (idempotent check)
	m, err := h.dbHandler.MessageGet(ctx, messageID)
	if err != nil {
		log.Errorf("Failed to get message: %v", err)
		return nil, err
	}

	var metadata message.Metadata
	json.Unmarshal([]byte(m.Metadata), &metadata)

	for _, r := range metadata.Reactions {
		if r.Emoji == emoji && r.OwnerType == ownerType && r.OwnerID == ownerID {
			// Already exists, return current message (idempotent)
			log.Debugf("Reaction already exists, returning current message")
			h.publishReactionUpdated(m)
			return m, nil
		}
	}

	// Add reaction atomically using MySQL JSON functions
	// This prevents race conditions when multiple users add reactions simultaneously
	now := time.Now().UTC().Format("2006-01-02T15:04:05.000000Z")
	reaction := message.Reaction{
		Emoji:     emoji,
		OwnerType: ownerType,
		OwnerID:   ownerID,
		TMCreate:  now,
	}
	reactionJSON, _ := json.Marshal(reaction)

	err = h.dbHandler.MessageAddReactionAtomic(ctx, messageID, string(reactionJSON))
	if err != nil {
		log.Errorf("Failed to add reaction atomically: %v", err)
		return nil, err
	}

	// Refresh and publish
	m, _ = h.dbHandler.MessageGet(ctx, messageID)
	h.publishReactionUpdated(m)

	return m, nil
}

func (h *reactionHandler) ReactionRemove(ctx context.Context, messageID uuid.UUID, emoji, ownerType string, ownerID uuid.UUID) (*message.Message, error) {
	// Remove reaction atomically
	err := h.dbHandler.MessageRemoveReactionAtomic(ctx, messageID, emoji, ownerType, ownerID)
	if err != nil {
		log.Errorf("Failed to remove reaction atomically: %v", err)
		return nil, err
	}

	// Refresh and publish
	m, _ := h.dbHandler.MessageGet(ctx, messageID)
	h.publishReactionUpdated(m)

	return m, nil
}

func (h *reactionHandler) publishReactionUpdated(m *message.Message) {
	var medias []message.Media
	json.Unmarshal([]byte(m.Medias), &medias)

	var metadata message.Metadata
	json.Unmarshal([]byte(m.Metadata), &metadata)

	webhookMsg := message.WebhookMessage{
		Identity: m.Identity,
		Owner:    m.Owner,
		ChatID:   m.ChatID,
		ParentID: m.ParentID,
		Type:     m.Type,
		Text:     m.Text,
		Medias:   medias,
		Metadata: metadata,
		TMCreate: m.TMCreate,
		TMUpdate: m.TMUpdate,
		TMDelete: m.TMDelete,
	}
	h.notifyHandler.PublishWebhook("message_reaction_updated", webhookMsg)
}
```

**Step 3: Generate mocks**

Run:
```bash
cd bin-talk-manager/pkg/reactionhandler
go generate
```

**Step 4: Commit**

```bash
git add pkg/reactionhandler/
git commit -m "feat(talk-manager): add reaction business logic handler"
```

---

## Phase 4: API Integration

### Task 4.1: Update bin-common-handler with Queue Names

**Files:**
- Modify: `bin-common-handler/models/outline/queuename.go`
- Modify: `bin-common-handler/models/outline/service.go`

**Step 1: Add queue name constants**

Find `QueueNameChatRequest` in `bin-common-handler/models/outline/queuename.go` and add after it:
```go
QueueNameTalkRequest   = "bin-manager.talk.request"
QueueNameTalkEvent     = "bin-manager.talk.event"
QueueNameTalkSubscribe = "bin-manager.talk.subscribe"
```

**Step 2: Add service name constant**

Find `ServiceNameChat` in `bin-common-handler/models/outline/service.go` and add after it:
```go
ServiceNameTalk = "talk"
```

**Step 3: Update bin-common-handler dependencies**

Run:
```bash
cd bin-common-handler
go mod tidy
go mod vendor
go generate ./...
go test ./...
```

**Step 4: Commit**

```bash
cd /home/pchero/gitvoipbin/monorepo
git add bin-common-handler/models/outline/
git commit -m "feat(common-handler): add talk-manager queue and service names"
```

---

### Task 4.2: Create Listen Handler (RabbitMQ RPC Router)

**Files:**
- Create: `bin-talk-manager/pkg/listenhandler/main.go`
- Create: `bin-talk-manager/pkg/listenhandler/v1_talks.go`
- Create: `bin-talk-manager/pkg/listenhandler/v1_messages.go`
- Create: `bin-talk-manager/pkg/listenhandler/v1_participants.go`
- Create: `bin-talk-manager/pkg/listenhandler/v1_reactions.go`

**Step 1: Write listen handler main**

Content for `bin-talk-manager/pkg/listenhandler/main.go`:
```go
package listenhandler

import (
	"context"
	"regexp"

	"github.com/sirupsen/logrus"

	"monorepo/bin-talk-manager/pkg/messagehandler"
	"monorepo/bin-talk-manager/pkg/participanthandler"
	"monorepo/bin-talk-manager/pkg/reactionhandler"
	"monorepo/bin-talk-manager/pkg/talkhandler"
	commonsock "monorepo/bin-common-handler/models/sock"
	commonsockhandler "monorepo/bin-common-handler/pkg/sockhandler"
)

// Regex patterns for URI matching
var (
	regV1Talks            = regexp.MustCompile(`^/v1/talks$`)
	regV1TalksID          = regexp.MustCompile(`^/v1/talks/([^/]+)$`)
	regV1TalksIDParticipants = regexp.MustCompile(`^/v1/talks/([^/]+)/participants$`)
	regV1TalksIDParticipantsID = regexp.MustCompile(`^/v1/talks/([^/]+)/participants/([^/]+)$`)
	regV1Messages         = regexp.MustCompile(`^/v1/messages$`)
	regV1MessagesID       = regexp.MustCompile(`^/v1/messages/([^/]+)$`)
	regV1MessagesIDReactions = regexp.MustCompile(`^/v1/messages/([^/]+)/reactions$`)
)

type listenHandler struct {
	sockHandler         commonsockhandler.SockHandler
	talkHandler         talkhandler.TalkHandler
	messageHandler      messagehandler.MessageHandler
	participantHandler  participanthandler.ParticipantHandler
	reactionHandler     reactionhandler.ReactionHandler
}

// New creates a new listen handler
func New(
	sock commonsockhandler.SockHandler,
	talk talkhandler.TalkHandler,
	msg messagehandler.MessageHandler,
	part participanthandler.ParticipantHandler,
	react reactionhandler.ReactionHandler,
) *listenHandler {
	return &listenHandler{
		sockHandler:         sock,
		talkHandler:         talk,
		messageHandler:      msg,
		participantHandler:  part,
		reactionHandler:     react,
	}
}

// Listen starts listening for RabbitMQ messages
func (h *listenHandler) Listen(ctx context.Context) {
	h.sockHandler.SubscribeSync(ctx, h.processRequest)
}

// processRequest routes incoming requests to appropriate handlers
func (h *listenHandler) processRequest(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	log.Debugf("Received request: %s %s", m.Method, m.URI)

	// Route based on URI pattern
	switch {
	case regV1Talks.MatchString(m.URI):
		return h.processV1Talks(ctx, m)
	case regV1TalksID.MatchString(m.URI):
		return h.processV1TalksID(ctx, m)
	case regV1TalksIDParticipants.MatchString(m.URI):
		return h.processV1TalksIDParticipants(ctx, m)
	case regV1TalksIDParticipantsID.MatchString(m.URI):
		return h.processV1TalksIDParticipantsID(ctx, m)
	case regV1Messages.MatchString(m.URI):
		return h.processV1Messages(ctx, m)
	case regV1MessagesID.MatchString(m.URI):
		return h.processV1MessagesID(ctx, m)
	case regV1MessagesIDReactions.MatchString(m.URI):
		return h.processV1MessagesIDReactions(ctx, m)
	default:
		log.Warnf("Unknown URI: %s", m.URI)
		return simpleResponse(404), nil
	}
}

// simpleResponse creates a simple response with status code
func simpleResponse(statusCode int) commonsock.Response {
	return commonsock.Response{
		StatusCode: statusCode,
		DataType:   "application/json",
		Data:       "{}",
	}
}
```

**Step 2: Implement talks endpoint handler**

Content for `bin-talk-manager/pkg/listenhandler/v1_talks.go`:
```go
package listenhandler

import (
	"context"
	"encoding/json"
	"net/url"
	"strconv"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	commonsock "monorepo/bin-common-handler/models/sock"
	"monorepo/bin-talk-manager/models/talk"
)

func (h *listenHandler) processV1Talks(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	switch m.Method {
	case "POST":
		return h.v1TalksPost(ctx, m)
	case "GET":
		return h.v1TalksGet(ctx, m)
	default:
		return simpleResponse(405), nil
	}
}

func (h *listenHandler) v1TalksPost(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	var req struct {
		CustomerID string `json:"customer_id"`
		Type       string `json:"type"`
	}

	err := json.Unmarshal(m.Data.([]byte), &req)
	if err != nil {
		log.Errorf("Failed to parse request: %v", err)
		return simpleResponse(400), nil
	}

	customerID := uuid.FromStringOrNil(req.CustomerID)
	if customerID == uuid.Nil {
		return simpleResponse(400), nil
	}

	t, err := h.talkHandler.TalkCreate(ctx, customerID, talk.Type(req.Type))
	if err != nil {
		return simpleResponse(500), nil
	}

	data, _ := json.Marshal(t)
	return commonsock.Response{
		StatusCode: 201,
		DataType:   "application/json",
		Data:       string(data),
	}, nil
}

func (h *listenHandler) v1TalksGet(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	u, _ := url.Parse(m.URI)

	// Parse pagination
	tmpSize, _ := strconv.Atoi(u.Query().Get("page_size"))
	pageSize := uint64(tmpSize)
	if pageSize == 0 {
		pageSize = 50
	}
	pageToken := u.Query().Get("page_token")

	// Parse filters from request body
	var filters map[string]any
	if m.Data != nil {
		json.Unmarshal(m.Data.([]byte), &filters)
	}

	// TODO: Convert filters to typed filters using utilhandler

	talks, err := h.talkHandler.TalkList(ctx, nil, pageToken, pageSize)
	if err != nil {
		return simpleResponse(500), nil
	}

	data, _ := json.Marshal(talks)
	return commonsock.Response{
		StatusCode: 200,
		DataType:   "application/json",
		Data:       string(data),
	}, nil
}

func (h *listenHandler) processV1TalksID(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	matches := regV1TalksID.FindStringSubmatch(m.URI)
	talkID := uuid.FromStringOrNil(matches[1])

	switch m.Method {
	case "GET":
		t, err := h.talkHandler.TalkGet(ctx, talkID)
		if err != nil {
			return simpleResponse(404), nil
		}
		data, _ := json.Marshal(t)
		return commonsock.Response{
			StatusCode: 200,
			DataType:   "application/json",
			Data:       string(data),
		}, nil

	case "DELETE":
		t, err := h.talkHandler.TalkDelete(ctx, talkID)
		if err != nil {
			return simpleResponse(500), nil
		}
		data, _ := json.Marshal(t)
		return commonsock.Response{
			StatusCode: 200,
			DataType:   "application/json",
			Data:       string(data),
		}, nil

	default:
		return simpleResponse(405), nil
	}
}
```

**Step 3: Implement remaining endpoint handlers (messages, participants, reactions)**

*(Similar pattern - create v1_messages.go, v1_participants.go, v1_reactions.go)*

For brevity, I'll provide skeleton files:

Content for `bin-talk-manager/pkg/listenhandler/v1_messages.go`:
```go
package listenhandler

import (
	"context"
	"encoding/json"

	"github.com/gofrs/uuid"
	commonsock "monorepo/bin-common-handler/models/sock"
	"monorepo/bin-talk-manager/pkg/messagehandler"
)

func (h *listenHandler) processV1Messages(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	switch m.Method {
	case "POST":
		return h.v1MessagesPost(ctx, m)
	case "GET":
		return h.v1MessagesGet(ctx, m)
	default:
		return simpleResponse(405), nil
	}
}

func (h *listenHandler) v1MessagesPost(ctx context.Context, m commonsock.Request) (commonsock.Response, error) {
	var req struct {
		CustomerID string  `json:"customer_id"`
		ChatID     string  `json:"chat_id"`
		ParentID   *string `json:"parent_id,omitempty"`
		OwnerType  string  `json:"owner_type"`
		OwnerID    string  `json:"owner_id"`
		Type       string  `json:"type"`
		Text       string  `json:"text"`
		Medias     string  `json:"medias"`
	}

	err := json.Unmarshal(m.Data.([]byte), &req)
	if err != nil {
		return simpleResponse(400), nil
	}

	customerID := uuid.FromStringOrNil(req.CustomerID)
	chatID := uuid.FromStringOrNil(req.ChatID)
	ownerID := uuid.FromStringOrNil(req.OwnerID)

	var parentID *uuid.UUID
	if req.ParentID != nil {
		pid := uuid.FromStringOrNil(*req.ParentID)
		parentID = &pid
	}

	createReq := messagehandler.MessageCreateRequest{
		CustomerID: customerID,
		ChatID:     chatID,
		ParentID:   parentID,
		OwnerType:  req.OwnerType,
		OwnerID:    ownerID,
		Type:       message.Type(req.Type),
		Text:       req.Text,
		Medias:     req.Medias,
	}

	msg, err := h.messageHandler.MessageCreate(ctx, createReq)
	if err != nil {
		return simpleResponse(500), nil
	}

	data, _ := json.Marshal(msg)
	return commonsock.Response{
		StatusCode: 201,
		DataType:   "application/json",
		Data:       string(data),
	}, nil
}

// Add v1MessagesGet, processV1MessagesID, etc.
```

**Step 4: Commit**

```bash
git add pkg/listenhandler/
git commit -m "feat(talk-manager): add RabbitMQ RPC listen handler with routing"
```

---

### Task 4.3: Wire Everything Together in main.go

**Files:**
- Modify: `bin-talk-manager/cmd/talk-manager/main.go`

**Step 1: Update main.go to initialize all handlers**

Replace the `// TODO: Initialize handlers` section with:
```go
	// Initialize Redis
	redisClient := redis.NewClient(&redis.Options{
		Addr:     cfg.RedisAddress,
		Password: cfg.RedisPassword,
		DB:       cfg.RedisDatabase,
	})
	defer redisClient.Close()
	log.Infof("Redis initialized")

	// Initialize database handler
	dbHandler := dbhandler.New(db, redisClient)

	// Initialize business logic handlers
	talkHandler := talkhandler.New(dbHandler, sockHandler)
	messageHandler := messagehandler.New(dbHandler, sockHandler)
	participantHandler := participanthandler.New(dbHandler, sockHandler)
	reactionHandler := reactionhandler.New(dbHandler, sockHandler)

	// Initialize listen handler
	listenHandler := listenhandler.New(
		sockHandler,
		talkHandler,
		messageHandler,
		participantHandler,
		reactionHandler,
	)

	// Start listening for RabbitMQ messages
	ctx := context.Background()
	go listenHandler.Listen(ctx)
	log.Infof("Listening for RabbitMQ messages on queue: %s", cfg.RabbitQueueListen)
```

Also add imports at the top:
```go
import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/go-redis/redis/v8"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"monorepo/bin-talk-manager/internal/config"
	"monorepo/bin-talk-manager/pkg/dbhandler"
	"monorepo/bin-talk-manager/pkg/listenhandler"
	"monorepo/bin-talk-manager/pkg/messagehandler"
	"monorepo/bin-talk-manager/pkg/participanthandler"
	"monorepo/bin-talk-manager/pkg/reactionhandler"
	"monorepo/bin-talk-manager/pkg/talkhandler"
	commondb "monorepo/bin-common-handler/pkg/databasehandler"
	commonsock "monorepo/bin-common-handler/pkg/sockhandler"
)
```

**Step 2: Build and verify**

Run:
```bash
cd bin-talk-manager
go mod tidy
go mod vendor
go build ./cmd/talk-manager
```

Expected: Compiles successfully

**Step 3: Clean up**

Run: `rm talk-manager`

**Step 4: Commit**

```bash
git add cmd/talk-manager/main.go go.mod go.sum vendor/
git commit -m "feat(talk-manager): wire all handlers together in main"
```

---

### Task 4.4: Update All Services After bin-common-handler Changes

**Files:**
- Modify: All `*/go.mod`, `*/go.sum`, `*/vendor/` across monorepo

**Step 1: Update all services**

Run:
```bash
cd /home/pchero/gitvoipbin/monorepo

find . -maxdepth 2 -name "go.mod" -execdir bash -c \
  "echo 'Updating $(basename $(pwd))...' && \
   go mod tidy && \
   go mod vendor" \;
```

Expected: All services updated with new bin-common-handler changes

**Step 2: Commit dependency updates**

```bash
git add */go.mod */go.sum
git commit -m "chore: update dependencies after bin-common-handler changes"
```

---

## Summary & Next Steps

This implementation plan covers **Phases 1-4** of the bin-talk-manager service:

✅ **Phase 1: Service Scaffolding** - Directory structure, go.mod, config, database migrations, main entry point

✅ **Phase 2: Core Models & Database** - Talk/Message/Participant models, database handler with CRUD operations

✅ **Phase 3: Business Logic** - Talk/Message/Participant/Reaction handlers with validation and webhook events

✅ **Phase 4: API Integration** - Listen handler for RabbitMQ RPC, bin-common-handler updates

**What's NOT in this plan (future work):**

- **Phase 5: Testing & Deployment** - Integration tests, load tests, Kubernetes deployment, Swagger docs
- **Phase 6: Client Migration** - Updating bin-api-manager routes, external client migration
- **Additional handlers:** Implement remaining listenhandler endpoint methods (some are skeletons)
- **Filter parsing:** Add utilhandler integration for type-safe filter parsing
- **OpenAPI specs:** Create OpenAPI definitions in bin-openapi-manager

**Estimated completion:** Phases 1-4 should take approximately 2-3 days of focused development work.

---

**For Claude:** Use superpowers:executing-plans or superpowers:subagent-driven-development to implement this plan task-by-task.
